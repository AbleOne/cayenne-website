<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title xmlns:d="http://docbook.org/ns/docbook">Chapter&nbsp;11.&nbsp;Performance Tuning</title><link rel="stylesheet" type="text/css" href="css/cayenne-doc.css"><meta xmlns:d="http://docbook.org/ns/docbook" name="keywords" content="Cayenne 4.0 documentation"><meta xmlns:d="http://docbook.org/ns/docbook" name="description" content="User documentation for Apache Cayenne version 4.0"><link rel="home" href="index.html" title="Cayenne Guide"><link rel="up" href="cayenne-guide-part2.html" title="Part&nbsp;II.&nbsp;Cayenne Framework"><link rel="prev" href="lifecycle-events.html" title="Chapter&nbsp;10.&nbsp;Lifecycle Events"><link rel="next" href="customizing-cayenne-runtime.html" title="Chapter&nbsp;12.&nbsp;Customizing Cayenne Runtime"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7036673-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
        </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:d="http://docbook.org/ns/docbook" class="navheader"><table width="100%" summary="Navigation header"><tr><th class="versioninfo">v.4.0 (4.0.M5)</th><th align="center">Chapter&nbsp;11.&nbsp;Performance Tuning</th><th></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="lifecycle-events.html">Prev</a>&nbsp;</td><th width="60%" align="center"><a accesskey="u" href="cayenne-guide-part2.html">Part&nbsp;II.&nbsp;Cayenne Framework</a></th><td width="20%" align="right">&nbsp;<a accesskey="n" href="customizing-cayenne-runtime.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="performance-tuning"></a>Chapter&nbsp;11.&nbsp;Performance Tuning</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="performance-tuning.html#prefetching">Prefetching</a></span></dt><dt><span class="section"><a href="performance-tuning.html#datarows">Data Rows</a></span></dt><dt><span class="section"><a href="performance-tuning.html#specific-attributes-with-ejbql">Specific Attributes and Relationships with EJBQL</a></span></dt><dt><span class="section"><a href="performance-tuning.html#iterated-queries">Iterated Queries</a></span></dt><dt><span class="section"><a href="performance-tuning.html#paginated-queries">Paginated Queries</a></span></dt><dt><span class="section"><a href="performance-tuning.html#caching-and-fresh-data">Caching and Fresh Data</a></span></dt><dt><span class="section"><a href="performance-tuning.html#turning-off-synchronization-of-objectcontexts">Turning off Synchronization of ObjectContexts</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="prefetching"></a>Prefetching</h2></div></div></div><p>Prefetching is a technique that allows to bring back in one query not only the queried
            objects, but also objects related to them. In other words it is a controlled eager
            relationship resolving mechanism. Prefetching is discussed in the "Performance Tuning"
            chapter, as it is a powerful performance optimization method. However another common
            application of prefetching is to refresh stale object relationships, so more generally
            it can be viewed as a technique for managing subsets of the object graph.</p><p>Prefetching example:
            </p><pre class="programlisting">ObjectSelect&lt;Artist&gt; query = ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>);

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// instructs Cayenne to prefetch one of Artist's relationships</span>
query.prefetch(Artist.PAINTINGS.disjoint());

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// the above line is equivalent to the following: </span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// query.prefetch("paintings", PrefetchTreeNode.DISJOINT_PREFETCH_SEMANTICS);</span>

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// query is expecuted as usual, but the resulting Artists will have</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// their paintings "inflated"</span>
List&lt;Artist&gt; artists = query.select(context);</pre><p>All
            types of relationships can be preftetched - to-one, to-many, flattened. A prefetch can
            span multiple relationships:
            </p><pre class="programlisting">query.prefetch(Artist.PAINTINGS.dot(Painting.GALLERY).disjoint());</pre><p>A query can have multiple
            prefetches:</p><pre class="programlisting">query.prefetch(Artist.PAINTINGS.disjoint());
query.prefetch(Artist.PAINTINGS.dot(Painting.GALLERY).disjoint());</pre><p>If a query is fetching DataRows, all "disjoint" prefetches are ignored, only "joint"
            prefetches are executed (see prefetching semantics discussion below for what disjoint and
            joint prefetches mean).</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prefetching-semantics"></a>Prefetching Semantics</h3></div></div></div><p>Prefetching semantics defines a strategy to prefetch relationships. Depending on
                it, Cayenne would generate different types of queries. The end result is the same -
                query root objects with related objects fully resolved. However semantics can affect
                preformance, in some cases significantly. There are 3 types of prefetch semantics,
                all defined as constants in
                <code class="code">org.apache.cayenne.query.PrefetchTreeNode</code>:</p><pre class="programlisting">PrefetchTreeNode.JOINT_PREFETCH_SEMANTICS
PrefetchTreeNode.DISJOINT_PREFETCH_SEMANTICS
PrefetchTreeNode.DISJOINT_BY_ID_PREFETCH_SEMANTICS</pre><p>There's no limitation on mixing different types of semantics in the same query.
                Each prefetch can have its own semantics. <code class="code">SelectQuery</code> uses
                    <code class="code">DISJOINT_PREFETCH_SEMANTICS</code> by default. <code class="code">ObjectSelect</code>
                requires explicit semantics as we've seen above. <code class="code">SQLTemplate</code> and
                    <code class="code">ProcedureQuery</code> are both using <code class="code">JOINT_PREFETCH_SEMANTICS</code>
                and it can not be changed due to the nature of those two queries.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="disjoint-prefetch-semantics"></a>Disjoint Prefetching Semantics</h3></div></div></div><p>This semantics results in Cayenne generatiing one SQL statement for the main
                objects, and a separate statement for each prefetch path (hence "disjoint" - related
                objects are not fetched with the main query). Each additional SQL statement uses a
                qualifier of the main query plus a set of joins traversing the preftech path between
                the main and related entity. </p><p>This strategy has an advantage of efficient JVM memory use, and faster overall
                result processing by Cayenne, but it requires (1+N) SQL statements to be executed,
                where N is the number of prefetched relationships.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="disjoint-by-id-prefetch-semantics"></a>Disjoint-by-ID Prefetching Semantics</h3></div></div></div><p>This is a variation of disjoint prefetch where related objects are matched against
                a set of IDs derived from the fetched main objects (or intermediate objects in a
                multi-step prefetch). Cayenne limits the size of the generated WHERE clause, as most
                DBs can't parse arbitrary large SQL. So prefetch queries are broken into smaller
                queries. The size of  is controlled by the DI property
                Constants.SERVER_MAX_ID_QUALIFIER_SIZE_PROPERTY (the default number of conditions in
                the generated WHERE clause is 10000). Cayenne will generate (1 + N * M) SQL
                statements for each query using disjoint-by-ID prefetches, where N is the number of
                relationships to prefetch, and M is the number of queries for a given prefetch that
                is dependent on the number of objects in the result (ideally M = 1).</p><p>The advantage of this type of prefetch is that matching database rows by ID may be
                much faster than matching the qualifier of the original query. Moreover this is
                    <span class="bold"><strong>the only type of prefetch</strong></span> that can handle
                SelectQueries with <span class="bold"><strong>fetch limit</strong></span>. Both joint and
                regular disjoint prefetches may produce invalid results or generate inefficient
                fetch-the-entire table SQL when fetch limit is in effect. </p><p>The disadvantage is that query SQL can get unwieldy for large result sets, as each
                object will have to have its own condition in the WHERE clause of the generated
                SQL.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="joint-prefetch-semantics"></a>Joint Prefetching Semantics</h3></div></div></div><p>Joint semantics results in a single SQL statement for root objects and any number
                of jointly prefetched paths. Cayenne processes in memory a cartesian product of the
                entities involved, converting it to an object tree. It uses OUTER joins to connect
                prefetched entities.</p><p>Joint is the most efficient prefetch type of the three as far as generated SQL
                goes. There's always just 1 SQL query generated. Its downsides are the potentially
                increased amount of data that needs to get across the network between the
                application server and the database, and more data processing that needs to be done
                on the Cayenne side.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prefetching-with-ejbql"></a>Similar Behaviours Using EJBQL</h3></div></div></div><p>It is possible to achieve similar behaviours with
            <a class="link" href="queries.html#ejbqlquery" title="EJBQLQuery">EJBQLQuery</a> queries by employing the "FETCH"
                keyword.</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">SELECT</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">FROM</span> Artist <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">LEFT</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">JOIN</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">FETCH</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span>.paintings</pre><p>
                In this case, the Paintings that exist for the Artist will be obtained at the same time
                as the Artists are fetched.  Refer to third-party query language documentation for further
                detail on this mechanism.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="datarows"></a>Data Rows</h2></div></div></div><p>Converting result set data to Persistent objects and registering these objects in the
            ObjectContext can be an expensive operation compareable to the time spent running the
            query (and frequently exceeding it). Internally Cayenne builds the result as a list of
            DataRows, that are later converted to objects. Skipping the last step and using data in
            the form of DataRows can significantly increase performance. </p><p>DataRow is a simply a map of values keyed by their DB column name. It is a ubiqutous
            representation of DB data used internally by Cayenne. And it can be quite usable as is
            in the application in many cases. So performance sensitive selects should consider
            DataRows - it saves memory and CPU cycles. All selecting queries support DataRows
            option,
            e.g.:</p><pre class="programlisting">ObjectSelect&lt;DataRow&gt; query = ObjectSelect.dataRowQuery(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>);

List&lt;DataRow&gt; rows = query.select(context);</pre><pre class="programlisting">SQLSelect&lt;DataRow&gt; query = SQLSelect.dataRowQuery(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"SELECT * FROM ARTIST"</span>);
List&lt;DataRow&gt; rows = query.select(context);</pre><p>Individual DataRows may be converted to Persistent objects as needed. So e.g. you may
            implement some in-memory filtering, only converting a subset of fetched
            objects:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// you need to cast ObjectContext to DataContext to get access to 'objectFromDataRow'</span>
DataContext dataContext = (DataContext) context;

<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">for</span>(DataRow row : rows) {
    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">if</span>(row.get(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"DATE_OF_BIRTH"</span>) != null) {
        Artist artist = dataContext.objectFromDataRow(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>, row);
        <span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// do something with Artist...</span>
        ...
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="specific-attributes-with-ejbql"></a>Specific Attributes and Relationships with EJBQL</h2></div></div></div><p>
            It is possible to fetch specific attributes and relationships from a model
            using <a class="link" href="queries.html#ejbqlquery" title="EJBQLQuery">EJBQLQuery</a>.
            The following example would return a java.util.List of String objects;
        </p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">SELECT</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span>.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">name</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">FROM</span> Artist <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span></pre><p>The following will yield a java.util.List containing Object[] instances, each of which
            would contain the name followed by the dateOfBirth value.</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">SELECT</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span>.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">name</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span>.dateOfBirth <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">FROM</span> Artist <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">a</span></pre><p>Refer to third-party query language documentation for further
            detail on this mechanism.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="iterated-queries"></a>Iterated Queries</h2></div></div></div><p>While contemporary hardware may easily allow applications to fetch hundreds of
            thousands or even millions of objects into memory, it doesn't mean this is always a good
            idea to do so. You can optimize processing of very large result sets with two techniques
            discussed in this and the following chapter - iterated and paginated queries. </p><p>Iterated query is not actually a special query. Any selecting query can be executed in
            iterated mode by an ObjectContext. ObjectContext creates an object called
                <code class="code">ResultIterator</code> that is backed by an open ResultSet. Iterator provides
            constant memory performance for arbitrarily large ResultSets. This is true at least on
            the Cayenne end, as JDBC driver may still decide to bring the entire ResultSet into the
            JVM memory. </p><p>Data is read from ResultIterator one row/object at a time until it is exhausted. There
            are two styles of accessing ResultIterator - direct access which requires explicit
            closing to avoid JDBC resources leak, or a callback that lets Cayenne handle resource
            management. In both cases iteration can be performed using "for" loop, as ResultIterator
            is "Iterable".</p><p>Direct access. Here common sense tells us that ResultIterators instances should be
            processed and closed as soon as possible to release the DB connection. E.g. storing open
            iterators between HTTP requests for unpredictable length of time would quickly exhaust
            the connection
            pool.</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">try</span>(ResultIterator&lt;Artist&gt; it = ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).iterator(context)) {
    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">for</span>(Artist a : it) {
       <span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// do something with the object...</span>
       ...
    }           
}</pre><p>Same thing with a
            callback:</p><pre class="programlisting">ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).iterate(context, (Artist a) -&gt; {
    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// do something with the object...</span>
    ...
});</pre><p>Another example is a batch iterator that allows to process more than one object in
            each iteration. This is a common scenario in various data processing jobs - read a batch
            of objects, process them, commit the results, and then repeat. This allows to further
            optimize processing (e.g. by avoiding frequent
            commits).</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">try</span>(ResultBatchIterator&lt;Artist&gt; it = ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).iterator(context)) {
    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">for</span>(List&lt;Artist&gt; list : it) {
       <span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// do something with each list</span>
       ...
       <span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// possibly commit your changes</span>
       context.commitChanges();
    }           
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="paginated-queries"></a>Paginated Queries</h2></div></div></div><p>Enabling query pagination allows to load very large result sets in a Java app with
            very little memory overhead (much smaller than even the DataRows option discussed
            above). Moreover it is completely transparent to the application - a user gets what
            appears to be a list of Persistent objects - there's no iterator to close or DataRows to
            convert to objects:</p><p>
            </p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// the fact that result is paginated is transparent</span>
List&lt;Artist&gt; artists = 
    ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).pageSize(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">50</span>).select(context);</pre><p>
        </p><p>Having said that, DataRows option can be combined with pagination, providing the best
            of both
            worlds:</p><pre class="programlisting">List&lt;DataRow&gt; rows = 
    ObjectSelect.dataRowQuery(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).pageSize(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">50</span>).select(context);</pre><p>The way pagination works internally, it first fetches a list of IDs for the root
            entity of the query. This is very fast and initially takes very little memory. Then when
            an object is requested at an arbitrary index in the list, this object and adjacent
            objects (a "page" of objects that is determined by the query pageSize parameter) are
            fetched together by ID. Subsequent requests to the objects of this "page" are served
            from memory.</p><p>An obvious limitation of pagination is that if you eventually access all objects in
            the list, the memory use will end up being the same as with no pagination. However it is
            still a very useful approach. With some lists (e.g. multi-page search results) only a
            few top objects are normally accessed. At the same time pagination allows to estimate
            the full list size without fetching all the objects. And again - it is completely
            transparent and looks like a normal query.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="caching-and-fresh-data"></a>Caching and Fresh Data</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="object-caching"></a>Object Caching</h3></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="query-result-caching"></a>Query Result Caching</h3></div></div></div><p>Cayenne supports mostly transparent caching of the query results. There are two
                levels of the cache: local (i.e. results cached by the ObjectContext) and shared
                (i.e. the results cached at the stack level and shared between all contexts). Local
                cache is much faster then the shared one, but is limited to a single context. It is
                often used with a shared read-only ObjectContext. </p><p>To take advantage of query result caching, the first step is to mark your queries
                appropriately. Here is an example for ObjectSelect query. Other types of queries
                have similar
                API:</p><pre class="programlisting">ObjectSelect.query(Artist.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).localCache(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"artists"</span>);</pre><p>This tells Cayenne that the query created here would like to use local cache of
                the context it is executed against. A vararg parameter to <code class="code">localCache()</code>
                (or <code class="code">sharedCache()</code>) method contains so called "cache groups". Those are
                arbitrary names that allow to categorize queries for the purpose of setting cache
                policies or explicit invalidation of the cache. More on that below.</p><p>The above API is enough for the caching to work, but by default your cache is an
                unmanaged LRU map. You can't control its size, expiration policies, etc. For the
                managed cache, you will need to explicitly use one of the more advanced cache
                providers. One such provider available in Cayenne is a provider for <a class="link" href="http://www.ehcache.org/" target="_top">EhCache</a>. It can be enabled on
                ServerRuntime startup in a custom
                Module:</p><pre class="programlisting">ServerRuntimeBuilder
  .builder()
  .addModule((binder) -&gt; 
     binder.bind(QueryCache.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>).to(EhCacheQueryCache.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>)
  )
  .build();</pre><p>By default EhCache reads a file called "ehcache.xml" located on classpath. You can
                put your cache configuration in that file.
                E.g.:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&lt;ehcache</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">xmlns:xsi</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">xsi:noNamespaceSchemaLocation</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"ehcache.xsd"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">updateCheck</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"false"</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">monitoring</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"off"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">dynamicConfig</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"false"</span><span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&gt;</span>

	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&lt;defaultCache</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">maxEntriesLocalHeap</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"1000"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">eternal</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"false"</span>
		<span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">overflowToDisk</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"false"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">timeToIdleSeconds</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"3600"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">timeToLiveSeconds</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"3600"</span><span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&gt;</span>
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&lt;/defaultCache&gt;</span>
	
	<span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&lt;cache</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"artists"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">timeToLiveSeconds</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"20"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute">maxEntriesLocalHeap</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value">"100"</span><span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag"> /&gt;</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-tag">&lt;/ehcache&gt;</span></pre><p>The example shows how to configure default cache settings ("defaultCache") as well
                as settings for a named cache group ("artists"). For many other things you can put
                in "ehcache.xml" refer to EhCache docs.</p><p>Often "passive" cache expiration policies similar to shown above are not
                sufficient, and the users want real-time cache invalidation when the data changes.
                So in addition to those policies, the app can invalidate individual cache groups
                explicitly with
                <code class="code">RefreshQuery</code>:</p><pre class="programlisting">RefreshQuery refresh = <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</span> RefreshQuery(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"artist"</span>);
context.performGenericQuery(refresh);</pre><p>The above can be used e.g. to build UI for manual cache invalidation. It is also
                possible to automate cache refresh when certain entities are committed. This
                requires including <code class="code">cayenne-lifecycle.jar</code> deoendency. From that library
                you will need two things: <code class="code">@CacheGroups</code> annotation to mark entities that
                generate cache invalidation events and &nbsp;<code class="code">CacheInvalidationFilter</code> that
                catches the updates to the annotated objects and generates appropriate invalidation
                events:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-comment">// configure filter on startup</span>
ServerRuntimeBuilder
  .builder()
  .addModule((binder) -&gt; 
     binder.bindList(Constants.SERVER_DOMAIN_FILTERS_LIST).add(CacheInvalidationFilter.<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span>)
  )
  .build();</pre><p>Now you can associate entities with cache groups, so that commits to those
                entities would atomatically invalidate the
                groups:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@CacheGroups("artists")</span>
<span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> Artist <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">extends</span> _Artist {
}</pre><p>Finally you may cluster cache group events. They are very small and can be
                efficiently sent over the wire to other JVMs running Cayenne. An example of Cayenne
                setup with event clustering  is <a class="link" href="https://github.com/andrus/wowodc13/tree/master/services/src/main/java/demo/services/cayenne" target="_top">available on GitHub</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="turning-off-synchronization-of-objectcontexts"></a>Turning off Synchronization of ObjectContexts</h2></div></div></div><p>By default when a single ObjectContext commits its changes, all other contexts in the
            same runtime receive an event that contains all the committed changes. This allows them
            to update their cached object state to match the latest committed data. There are
            however many problems with this ostensibly helpful feature. In short - it works well in
            environments with few contexts and in unclustered scenarios, such as single user desktop
            applications, or simple webapps with only a few users. More specifically:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The performance of synchronization is (probably worse than) O(N) where N
                        is the number of peer ObjectContexts in the system. In a typical webapp N
                        can be quite large. Besides for any given context, due to locking on
                        synchronization, context own performance will depend not only on the queries
                        that it runs, but also on external events that it does not control. This is
                        unacceptable in most situations. </p></li><li class="listitem"><p>Commit events are untargeted - even contexts that do not hold a given
                        updated object will receive the full event that they will have to
                        process.</p></li><li class="listitem"><p>Clustering between JVMs doesn't scale - apps with large volumes of commits
                        will quickly saturate the network with events, while most of those will be
                        thrown away on the receiving end as mentioned above.</p></li><li class="listitem"><p>Some contexts may not want to be refreshed. A refresh in the middle of an
                        operation may lead to unpredictable results. </p></li><li class="listitem"><p>Synchronization will interfere with optimistic locking. </p></li></ul></div><p>So we've made a good case for disabling synchronization in most webapps.
            To do that, set to "false" the following DI property -
                <code class="code">Constants.SERVER_CONTEXTS_SYNC_PROPERTY</code>, using one of the standard
            Cayenne DI approaches. E.g. from command
            line:</p><pre class="screen"><code class="prompt">$</code> java -Dcayenne.server.contexts_sync_strategy=false</pre><p>Or
            by changing the standard properties Map in a custom extensions
            module:</p><pre class="programlisting"><span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</span> MyModule <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">implements</span> Module {

    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-annotation">@Override</span>
    <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</span> configure(Binder binder) {
        binder.bindMap(Constants.PROPERTIES_MAP).put(Constants.SERVER_CONTEXTS_SYNC_PROPERTY, <span xmlns="http://www.w3.org/1999/xhtml" class="hl-string">"false"</span>);
    }
}</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lifecycle-events.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="cayenne-guide-part2.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="customizing-cayenne-runtime.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Lifecycle Events&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Customizing Cayenne Runtime</td></tr></table></div></body></html>